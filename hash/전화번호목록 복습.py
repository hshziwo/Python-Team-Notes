# https://school.programmers.co.kr/questions/39655


def solution(phone_book):
    phone_book.sort()
    for i in range(len(phone_book) - 1):
        if phone_book[i] == phone_book[i + 1][: len(phone_book[i])]:
            return False
    return True


# 입력 배열을 사전순으로 정렬한 결과가 ["119", "1291", "2345", "3456"]라고 생각해 보겠습니다.
# 작성해 주신 코드의 비교 순서는 다음과 같습니다.

# i	j
# 119	119
# 119	1291
# 119	2345
# 119	3456
# 1291	119
# 1291	1291
# 1291	2345
# ...	...
# 3456	2345
# 3456	3456
# 이 경우에 배열 길이가 n이라면 총 n2 번 비교를 하게 됩니다. 그런데.. 잘 생각해보면 모든 쌍에 대해서 비교를 수행하지 않아도 됩니다.
# 예를 들어 i = "119"와 j = "1291"을 비교한 후에 접두어가 아닌 경우 i = "119"와 j = "2345"를 비교할 필요가 있을까요? 배열이 사전순으로 정렬되어 있기 때문에, "1291"뒤에는 "119"로 시작하는 문자열이 올 수 없습니다(사전순 정렬의 의미에 따라 "119"로 시작하는 문자열끼리 뭉쳐있을 것이라고 생각해보면 됩니다). 따라서 j = "1291"이후의 문자열에 "119"로 시작하는 문자열은 없으므로, i = "119"와 비교하는 부분은 불필요한 연산이 되지요.

# 따라서, "119"가 "1291"의 접두어가 아니라면, 남아있는 비교 연산을 수행하지 않고 그냥 i = "1291"과 j = "2345"를 비교하는 부분으로 건너뛰어도 됩니다(i = "1291"과 j = "119"를 비교하지 않아도 되는 이유 역시 마찬가지로, 이미 이전에 비교를 했기 때문입니다. "119"와 "1291"을 비교하는 것은 "1291"과 "119"를 비교하는것과 같으니까요).

# 위 내용을 정리하면, 결국 문자열을 사전순으로 정렬한 경우 서로 붙어있는 문자열끼리만 비교해보면 접두어인 경우를 찾을 수 있습니다. 이 경우 붙어있는 문자열끼리만 비교하면 되므로, 전체 비교횟수는 n - 1번이 됩니다.

# 문자열의 개수 n = 1,000,000인 경우

# 모든 쌍에 대해 비교하는 경우의 횟수 = n2 = 1,000,0002 = 1,000,000,000,000 번의 연산이 필요
# 인접한 문자열끼리만 비교하는 경우의 횟수 = n - 1 = 999,999 번의 연산이 필요
# 1억번의 연산을 하는데 1초 정도 걸린다고 생각한다면, 위는 10,000초가 필요한 반면, 아래는 0.01초면 충분하지요

# 이 문제에서 실제 걸리는 시간은 문자열을 정렬하는데 필요한 시간과 문자열의 길이까지 고려해줘야 하며, 시간 복잡도는 O(nlogn)정도로 생각하면 됩니다.
