n, m = map(int, input().split())
array = []
for i in range(n):
    array.append(int(input()))

INF = 10001  # 여기서 문제 조건이 10000원까지라서
# dp테이블 초기화
d = [INF] * (m + 1)

# 보텀업 방식(작은거부터 큰거로, for문형태)으로 진행
# 0은 0개일때 0이므로 0으로 초기화
d[0] = 0

# 점화식 : a(i) = min(a(i), a(i-k) + 1) 현재의 옵티멀 갯수와 동전 하나 뺀 거의 옵티멀 갯수 + 1 중 작은 값을 선택
# 동전의 갯수 n까지 for문 시작
# 여기서 i는 array[i]로 쓰일꺼기 때문에
# 실제로는 가지고 있는 동전의 크기라고 볼 수 있음
# ex) array  = [2, 3, 5]
# 따라서 for문을 시작한다면 2원부터 차례대로 5원까지 for문이 돌꺼임
for i in range(n):
    # 여기서 j는 m원 즉 도달해야 하는 가겨을 뜻함. 하지만 dp 특성상 0원부터 m원까지의 모든 필요 갯수 dp테이블을 만들꺼임
    # 현재의 가진 동전 크기(array[i] ex)2부터) m원까지 돌면서 옵티멀 갯수 업데이트
    for j in range(array[i], m + 1):
        # (i - k)원을 만들 방법이 있으면
        if d[j - array[i]] != INF:
            # 점화식에 의해
            # 현재 갯수와 (i - k)원의 옵티멀 갯수 + 1 과 비교해서 작은 값을 현재의 옵티멀 수로 업데이트
            d[j] = min(d[j], d[j - array[i]] + 1)

# m원 만드는 방법 없으면 -1 출력
if d[m] == INF:
    print(-1)
else:
    # 있으면 m원에 대한 옵티멀 값 출력
    print(d[m])

# 입력값
# 2 15
# 2
# 3
# 출력값
# 5

# 입력값
# 3 4
# 3
# 5
# 7
# 출력값
# -1
