# 다이나믹 프로그래밍에 자주 나오는 문제인
# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 문제를 조금만 수정해서 풀어야 하는 문제
# LIS 알고리즘이란
# D(i) = array(i)를 마지막 원소로 가지는 부분 수열의 최대 길이
# 즉, 현재 원소까지의 수열의 길이들을 기록 해놓은 DP테이블이다.
# 0<= j < i 일때
# 점화식: D(i) = max(D(i), D(j) + 1) if array[j] < array[i]
# 해석: DP테이블은 현재 i까지의 수열의 길이(DP테이블값)와 i보다 하나 작은 j의 수열의 길이(DP테이블값)에 1을 +한 값 중 큰 것을 선택한다.
# 이 때, D(i), D(j) + 1 를 비교하는 이유는 수열의 길이이기 때문에 하나 더 기냐 짧냐로 생각해도 되기 때문
# 당연히 실제 i와 j의 원소값은 array[j] < array[i] 이 조건을 만족해야 한다.

# 이와 같은 LIS 알고리즘을 변형해서 풀어야 하는 문제
# LIS는 정렬을 하는 문제는 아닌데
# 여기 문제에서는 내림차순 배치를 원하므로 먼저 내림차순 정렬을 한 뒤에 LIS 알고리즘으로 풀면
# 현재 조건 N명에서의 최대 길이 즉, 전투력이 좋은 최적의 병사의 최대 수를 구할 수 있다.
# 옵티멀 값은 DP테이블 중 가장 큰 값이다. max(dp)
# 여기서는 열외시킬 수를 구하므로 해는 N - max(dp) 값이다.

import sys

input = lambda: sys.stdin.readline().rstrip()

n = int(input())  # 현재 병사수
array = list(map(int, input().split()))  # 병사들의 전투력 array

# 일단 높은 전투력 순이므로 내림차순 정렬함
array.reverse()

# dp테이블을 1의 값으로 초기화 함
# 왜냐하면 일단 자기자신이 있으면 길이가 1이므로
dp = [1] * n

# i가 1부터 시작하는 이유는 j인덱스가 0부터 시작되어야 0인덱스와 1인덱스부터 비교를 시작할 수 있기 때문
# i가 0이면 처음부터 자기자신과 비교하는 건 비효율 코드
for i in range(1, n):
    for j in range(0, i):
        # 점화식대로 DP테이블을 업데이트 시킴
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)

# 열외해야 할 병사 최소 수 출력
# max(dp)는 최적의 전투력 가진 병사수
print(n - max(dp))

# input 값
# 7
# 15 11 4 8 5 2 4
# output 값
# 2
