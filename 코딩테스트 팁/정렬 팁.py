# 선택 정렬: O(N2)복잡도, 이중 for문 구조로 for문 돌면서 현재 이외에 남은 것들 중 가장 작은 것과 현재의 것을 매번 바꿔주는 로직(오름차순 기준일때)

# 삽입 정렬 : O(N2)복잡도, 0인덱스가 아니라 1인덱스부터 시작해서 계속 for문 돌면서 이미 정렬된 왼쪽들의 값과 비교해서 자리를 스와핑해주는 방법
#     - 그러나 이미 정렬되어 있으면 O(N)으로 매우 빠르게 동작함 for문이 else에서 계속 break로 넘어가기 떄문

# 퀵 정렬:
# O(NlogN)복잡도, 피벗값이라는 기준값이 있고(처음에 0번쨰인덱스) 그 값을 기준으로 양쪽 끝에서 그 값의 i+1자리부터 오른쪽으로 피벗보다 큰값을 찾고,
# 오른쪽끝에서 왼쪽으로 피벗보다 작은 값을 찾고 두 값의 자리를 바꾸고 계속 진행 후 교차하는 지점이 있으면 그때의 작은 값이랑 피벗값이랑 값을 바꿔줌
# 바꿔준 자리를 기준으로 두 영역으로 분할(divide)됨 이렇게 분할된 영역에서 계속 퀵 정렬 수행하면 정렬 완료
#     - but 최악은 O(N2)-> 이미 정렬되어 있는 상황에서는 분할(divide)를 할때 양쪽 끝에서 왼쪽에서 오른쪽끝, 오른쪽끝에서 왼쪽끝까지 큰값, 작은값을 찾기 때문에 비효율
# - 파이썬 리스트 컨프리헨션을 사용하면 쉽게 구현 가능함

# 계수 정렬: 숫자를 정렬할 때 쓰일듯
# 최대값을 알아야 하고 최대값만큼의 크기의 array를 만들어서
# 정렬할 array를 차례로 돌면서 해당 값의 index에 +=1 카운팅을 해줌
# 이렇게 된 후에
# 결과 array를 돌면서 index의 카운트만큼 인덱스를 계속 프린트 해주면 정렬 끝
# ex) [0,0,1,1,2,2,3,3,4,5,5]
# 동일값이 많을 때 유리
